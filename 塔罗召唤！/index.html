<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>Mystic Tarot - 78 Destiny</title>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&family=Noto+Serif+SC:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body { margin: 0; overflow: hidden; background: #05010a; font-family: 'Cinzel', 'Noto Serif SC', serif; }
        #canvas-container { 
            width: 100vw; height: 100vh; display: block; position: absolute; z-index: 1;
            background: radial-gradient(circle at center, #1a0b2e 0%, #050108 100%);
        }
        #video-input { position: absolute; width: 1px; height: 1px; opacity: 0; }

        /* UI 层 */
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; display: flex; flex-direction: column; align-items: center; z-index: 10;
        }
        .hud-text {
            color: #ffd700; text-shadow: 0 0 15px rgba(255, 215, 0, 0.5); margin-top: 50px; font-size: 18px;
            background: rgba(15, 5, 25, 0.85); padding: 12px 40px; border-radius: 40px;
            border: 1px solid rgba(255, 215, 0, 0.3); letter-spacing: 2px;
        }

        #loader {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #0d0214; display: flex; flex-direction: column; justify-content: center; align-items: center;
            color: #ffd700; z-index: 99; transition: opacity 1.5s ease;
        }
        #start-btn {
            padding: 16px 50px; font-size: 20px; font-family: 'Cinzel', 'Noto Serif SC'; background: transparent; 
            color: #ffd700; border: 2px solid #ffd700; cursor: pointer; border-radius: 50px;
            box-shadow: 0 0 25px rgba(255, 215, 0, 0.2); transition: 0.4s; margin-top: 30px;
        }
        #start-btn:hover { background: #ffd700; color: #0d0214; box-shadow: 0 0 50px #ffd700; }

        #analysis-panel {
            position: absolute; bottom: -100%; left: 5%; width: 90%; height: 62%;
            background: linear-gradient(to top, rgba(10, 2, 20, 0.98), rgba(35, 12, 55, 0.95));
            backdrop-filter: blur(25px); border-top: 2px solid #ffd700; border-radius: 40px 40px 0 0;
            z-index: 20; transition: bottom 1.2s cubic-bezier(0.16, 1, 0.3, 1); 
            display: flex; flex-direction: column; color: #ffd700; padding: 35px; box-sizing: border-box;
        }
        .reading-box { flex:1; padding: 18px; border: 1px solid rgba(255, 215, 0, 0.15); border-radius: 15px; background: rgba(0,0,0,0.3); overflow-y: auto; }
        .reading-box h3 { margin-top: 0; color: #fff; border-bottom: 2px solid #ffd700; padding-bottom: 8px; font-size: 1.2em; text-align: center;}
        .card-title { font-size: 1.3em; font-weight: bold; display: block; margin: 10px 0; color: #fff; text-align: center;}
        .card-meta { font-style: italic; color: #ffa500; text-align: center; margin-bottom: 12px; }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.umd.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>

    <script src="tarot_data.js"></script>
</head>
<body>

    <div id="loader">
        <h1 style="letter-spacing: 12px; font-size: 45px; text-shadow: 0 0 30px #ffd700;">DESTINY REVEAL</h1>
        <p>全牌组 78 张塔罗秘仪已就绪</p>
        <button id="start-btn">开启命运观测</button>
    </div>

    <div id="ui-layer">
        <div id="instruction" class="hud-text">凝视深渊，握紧双拳，启动魔法阵</div>
    </div>

    <div id="analysis-panel">
        <h2 style="text-align: center; margin-top: 0; letter-spacing: 6px; font-size: 24px;">✧ 命运的真实形态 ✧</h2>
        <div style="display: flex; justify-content: space-around; gap: 20px; height: 85%;">
            <div class="reading-box"><h3>过去</h3><div id="read-past"></div></div>
            <div class="reading-box"><h3>现在</h3><div id="read-present"></div></div>
            <div class="reading-box"><h3>未来</h3><div id="read-future"></div></div>
        </div>
        <p style="text-align: center; font-size: 12px; opacity: 0.5; margin-top: 10px;">- 张开并收拢五指，清空时空重洗牌组 -</p>
    </div>

    <video id="video-input"></video>
    <div id="canvas-container"></div>

<script>
    // --- 数据库：78张牌全收录 ---
    // const tarotLibrary = [
    //     // 大阿卡纳
    //     { name: "愚者 The Fool", upright: "新的开始，自由，纯真，冒险。", reversed: "草率，鲁莽，缺乏经验。" },
    //     { name: "魔术师 The Magician", upright: "意志力，创造力，行动力。", reversed: "操纵，诡计，怀才不遇。" },
    //     { name: "女祭司 The High Priestess", upright: "直觉，潜意识，神秘，静止。", reversed: "浅薄，隐瞒，内心的混乱。" },
    //     { name: "皇后 The Empress", upright: "丰饶，母性，感官，美感。", reversed: "过度依赖，停滞，创造力受阻。" },
    //     { name: "皇帝 The Emperor", upright: "权威，结构，父性，保护。", reversed: "暴政，死板，缺乏自律。" },
    //     { name: "教皇 The Hierophant", upright: "传统，信仰，社会准则。", reversed: "叛逆，突破传统，盲从。" },
    //     { name: "恋人 The Lovers", upright: "结合，和谐，关系，选择。", reversed: "失调，冷战，错误的选择。" },
    //     { name: "战车 The Chariot", upright: "胜利，意志，自律，行动。", reversed: "失控，侵略性过强，挫折。" },
    //     { name: "力量 Strength", upright: "勇气，耐力，慈悲，内在控制。", reversed: "软弱，自卑，被本能支配。" },
    //     { name: "隐士 The Hermit", upright: "内省，寻求真理，独处，引导。", reversed: "孤立，孤独，偏见。" },
    //     { name: "命运之轮 Wheel of Fortune", upright: "好运，宿命，转折点。", reversed: "厄运，抗拒改变，意外停滞。" },
    //     { name: "正义 Justice", upright: "公正，诚实，法律，因果。", reversed: "不公，偏见，不负责任。" },
    //     { name: "倒吊人 The Hanged Man", upright: "牺牲，顿悟，新的视角。", reversed: "拖延，徒劳无获，错失良机。" },
    //     { name: "死神 Death", upright: "终结，转变，放下，新生。", reversed: "恐惧变化，停滞不前，慢性痛苦。" },
    //     { name: "节制 Temperance", upright: "平衡，节制，融合，耐性。", reversed: "失衡，冲突，过度消费。" },
    //     { name: "恶魔 The Devil", upright: "束缚，物质主义，成瘾，阴影。", reversed: "解脱，觉醒，打破枷锁。" },
    //     { name: "高塔 The Tower", upright: "突变，灾难，揭示，崩溃。", reversed: "幸免于难，推迟改变，内心挣扎。" },
    //     { name: "星星 The Star", upright: "希望，灵感，宁静，疗愈。", reversed: "失望，绝望，缺乏动力。" },
    //     { name: "月亮 The Moon", upright: "幻象，不安，直觉，迷茫。", reversed: "真相大白，恐惧消退，误解消除。" },
    //     { name: "太阳 The Sun", upright: "快乐，成功，活力，光明。", reversed: "暂时的阻碍，消沉，虚荣。" },
    //     { name: "审判 Judgement", upright: "觉醒，重生，因果报应。", reversed: "逃避现实，自责，犹豫不决。" },
    //     { name: "世界 The World", upright: "圆满，成就，旅行，完整。", reversed: "未完成，缺乏闭环，迟来的成功。" }
    // ];

    // // 快捷生成小阿卡纳（共56张）
    // ["权杖", "圣杯", "宝剑", "星币"].forEach(suit => {
    //     for(let i=1; i<=14; i++) {
    //         let rank = i === 1 ? "首领" : i === 11 ? "侍从" : i === 12 ? "骑士" : i === 13 ? "王后" : i === 14 ? "国王" : i;
    //         tarotLibrary.push({
    //             name: `${suit}${rank}`,
    //             upright: `在${suit}领域的全新动态与能量表现。`,
    //             reversed: `在${suit}领域遭遇的能量阻碍或负面偏差。`
    //         });
    //     }
    // });

    let scene, camera, renderer, cards = [], selectedCards = [], dustParticles;
    let currentState = 'INIT', selectTimer = null;
    let handSequence = { open: false, closed: false };

    function initThree() {
        if(renderer) return;
        const container = document.getElementById('canvas-container');
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 15, 25);
        camera.lookAt(0, 0, 0);

        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        container.appendChild(renderer.domElement);

        scene.add(new THREE.AmbientLight(0xffffff, 1.0));
        const light = new THREE.PointLight(0xffd700, 1.5, 100);
        light.position.set(0, 30, 10);
        scene.add(light);

        createTarotDeck();
        initDustParticles();
        animate();
    }

    function initDustParticles() {
        const geo = new THREE.BufferGeometry();
        const pos = new Float32Array(800 * 3);
        for(let i=0; i<800; i++) {
            pos[i*3] = (Math.random()-0.5)*80;
            pos[i*3+1] = Math.random()*40;
            pos[i*3+2] = (Math.random()-0.5)*50;
        }
        geo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
        dustParticles = new THREE.Points(geo, new THREE.PointsMaterial({ color: 0xffd700, size: 0.15, transparent: true, opacity: 0.4, blending: THREE.AdditiveBlending }));
        scene.add(dustParticles);
    }

    function createCardTexture(isBack, data) {
        const canvas = document.createElement('canvas');
        canvas.width = 512; canvas.height = 800;
        const ctx = canvas.getContext('2d');
        const r = 40;

        // 统一绘制圆角背景
        ctx.beginPath();
        ctx.moveTo(r, 0); ctx.lineTo(512-r, 0); ctx.quadraticCurveTo(512, 0, 512, r);
        ctx.lineTo(512, 800-r); ctx.quadraticCurveTo(512, 800, 512-r, 800);
        ctx.lineTo(r, 800); ctx.quadraticCurveTo(0, 800, 0, 800-r);
        ctx.lineTo(0, r); ctx.quadraticCurveTo(0, 0, r, 0);
        ctx.closePath();
        ctx.clip(); // 强制圆角切片

        if(isBack) {
            ctx.fillStyle = '#101835'; ctx.fillRect(0,0,512,800);
            ctx.strokeStyle = '#ffd700'; ctx.lineWidth = 15; ctx.stroke();
            ctx.lineWidth = 4; ctx.strokeRect(30, 30, 452, 740);
            // 六芒星
            ctx.save();
            ctx.translate(256, 400);
            for(let j=0; j<2; j++) {
                ctx.rotate(j === 0 ? 0 : Math.PI);
                ctx.beginPath();
                for(let i=0; i<3; i++) {
                    let a = (i * 120 - 90) * Math.PI / 180;
                    ctx.lineTo(Math.cos(a)*150, Math.sin(a)*150);
                }
                ctx.closePath(); ctx.lineWidth = 8; ctx.stroke();
            }
            ctx.restore();
        } else {
            ctx.fillStyle = '#fdfaf0'; ctx.fillRect(0,0,512,800);
            ctx.strokeStyle = '#444'; ctx.lineWidth = 8; ctx.strokeRect(20,20,472,760);
            ctx.fillStyle = '#111'; ctx.textAlign = 'center'; ctx.font = 'bold 45px "Noto Serif SC"';
            ctx.fillText(data.name.split(' ')[0], 256, 120);
            ctx.font = 'italic 25px Cinzel'; ctx.fillText(data.name.split(' ')[1] || "", 256, 160);
            ctx.font = '250px serif'; ctx.fillText("☯", 256, 480);
        }
        return new THREE.CanvasTexture(canvas);
    }

    function createTarotDeck() {
        const backTex = createCardTexture(true); // 这里生成的是带六芒星和金边的纹理
        // 1. 调整大小：在这里把 4.5 和 7.0 改大，比如 (5.2, 8.2, 0.15)
        const geometry = new THREE.BoxGeometry(5.2, 8.2, 0.15); 
        const shuffled = [...tarotLibrary].sort(() => Math.random() - 0.5);

        for (let i = 0; i < 20; i++) {
            const mats = Array(6).fill(new THREE.MeshStandardMaterial({color: 0x222}));
            
            // --- 核心修改点 ---
            // 将正面 (mats[4]) 也初始设置为六芒星纹理，这样扇形展开时不论哪面朝上都好看
            mats[4] = new THREE.MeshStandardMaterial({ map: backTex, roughness: 0.3, metalness: 0.3 }); 
            // 将背面 (mats[5]) 同样设置为六芒星纹理
            mats[5] = new THREE.MeshStandardMaterial({ map: backTex, roughness: 0.3, metalness: 0.3 }); 
            
            const card = new THREE.Mesh(geometry, mats);
            card.position.set(0, 0.1 * i, 0);
            card.rotation.set(-Math.PI / 2, 0, 0);
            
            // 2. 调整光圈大小：光圈要比卡牌稍微大一圈（比如卡牌5.2x8.2，光圈就5.5x8.5）
            const haloGeo = new THREE.PlaneGeometry(5.5, 8.5);
            const haloMat = new THREE.MeshBasicMaterial({ color: 0xffd700, transparent: true, opacity: 0, side: THREE.DoubleSide });
            const halo = new THREE.Mesh(haloGeo, haloMat);
            halo.position.z = -0.1;
            card.add(halo);

            card.userData = { 
                data: shuffled[i % shuffled.length],
                isRev: Math.random() > 0.5,
                halo: haloMat
            };
            cards.push(card);
            scene.add(card);
        }
    }

    function fanCards() {
        if(currentState !== 'INIT') return;
        currentState = 'FANNED';
        document.getElementById('instruction').innerText = "左右移动食指，感应牌组中的命运波动";
        const widthRange = 40; // 覆盖屏幕约75%-80%
        cards.forEach((card, i) => {
            const angle = (i / (cards.length - 1) - 0.5) * Math.PI * 0.85;
            const x = Math.sin(angle) * (widthRange / 2);
            const z = Math.cos(angle) * -10;
            new TWEEN.Tween(card.position).to({x: x, y: 1.5, z: z}, 1500).easing(TWEEN.Easing.Quartic.Out).start();
            new TWEEN.Tween(card.rotation).to({x: -Math.PI / 2.8, y: 0, z: -angle}, 1500).start();
        });
    }

    function updateHover(fx) {
        if(currentState !== 'FANNED') return;
        let idx = Math.floor((1 - fx) * cards.length);
        idx = Math.max(0, Math.min(cards.length - 1, idx));
        cards.forEach((c, i) => {
            if(i === idx && !c.userData.selected) {
                c.position.y = 4.0; c.userData.halo.opacity = 0.6;
            } else if (!c.userData.selected) {
                c.position.y = 1.5; c.userData.halo.opacity = 0;
            }
        });
    }

    function pickCard(fx) {
        if(currentState !== 'FANNED' || selectedCards.length >= 3) return;
        let idx = Math.floor((1 - fx) * cards.length);
        idx = Math.max(0, Math.min(cards.length - 1, idx));
        const card = cards[idx];
        if(card.userData.selected) return;
        
        card.userData.selected = true;
        selectedCards.push(card);
        new TWEEN.Tween(card.position).to({x: -20 + selectedCards.length*5, y: 12, z: -10}, 1000).start();
        new TWEEN.Tween(card.scale).to({x: 0.3, y: 0.3, z: 0.3}, 1000).onComplete(() => {
            if(selectedCards.length === 3) revealSession();
        }).start();
    }

    function revealSession() {
        currentState = 'REVEALED';
        document.getElementById('instruction').innerText = "仪式完成，命运之扉已开启。";
        selectedCards.forEach((card, i) => {
            const isRev = card.userData.isRev;
            
            new TWEEN.Tween(card.position).to({x: (i-1)*8.5, y: 3, z: 12}, 1500).delay(800).start();
            new TWEEN.Tween(card.scale).to({x: 1.1, y: 1.1, z: 1.1}, 1500).delay(800).start();
            
            // 这里的旋转是关键：y轴旋转 0 或 2PI 会看到正面，旋转 PI 会看到背面
            // 配合 z 轴实现正逆位
            new TWEEN.Tween(card.rotation)
                .to({x: 0, y: 0, z: isRev ? Math.PI : 0}, 2000) 
                .delay(1800)
                .onStart(() => {
                    // 在翻转那一刻，把正面 mats[4] 换成真正的牌面
                    card.material[4].map = createCardTexture(false, card.userData.data);
                    card.material[4].needsUpdate = true;
                    card.userData.halo.opacity = 0;
                })
                .onComplete(() => {
                    if(i === 2) displayResult();
                }).start();
        });
    }

    function displayResult() {
        document.getElementById('analysis-panel').style.bottom = '0';
        ['past', 'present', 'future'].forEach((pos, i) => {
            const card = selectedCards[i];
            const data = card.userData.data;
            const isRev = card.userData.isRev;
            document.getElementById(`read-${pos}`).innerHTML = `
                <div class="card-title">${data.name}</div>
                <div class="card-meta">(${isRev ? '逆位 Reversed' : '正位 Upright'})</div>
                <div style="line-height:1.8;">${isRev ? data.reversed : data.upright}</div>
            `;
        });
    }

    function resetMagic() {
        if(currentState !== 'REVEALED') return;
        currentState = 'RESETTING';
        document.getElementById('analysis-panel').style.bottom = '-100%';
        cards.forEach((c, i) => {
            new TWEEN.Tween(c.position).to({y: 35, x: (Math.random()-0.5)*50}, 1000).start();
            new TWEEN.Tween(c.scale).to({x:0, y:0, z:0}, 1000).onComplete(() => {
                scene.remove(c);
                if(i === cards.length-1) {
                    cards = []; selectedCards = []; createTarotDeck();
                    currentState = 'INIT';
                    document.getElementById('instruction').innerText = "握紧双拳，感知下一次启示...";
                }
            }).start();
        });
    }

    function animate() {
        requestAnimationFrame(animate);
        TWEEN.update();
        if(dustParticles) {
            const posArr = dustParticles.geometry.attributes.position.array;
            for(let i=0; i<posArr.length; i+=3) {
                posArr[i+1] -= 0.02; if(posArr[i+1] < 0) posArr[i+1] = 40;
                posArr[i] += Math.sin(Date.now()*0.001 + posArr[i+1])*0.01;
            }
            dustParticles.geometry.attributes.position.needsUpdate = true;
        }
        renderer.render(scene, camera);
    }

    const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
    hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.75, minTrackingConfidence: 0.75 });
    
    hands.onResults(results => {
        if(!results.multiHandLandmarks || results.multiHandLandmarks.length === 0) return;
        const lm = results.multiHandLandmarks[0];
        const isFist = lm[8].y > lm[6].y && lm[12].y > lm[10].y;
        const isOpen = lm[8].y < lm[6].y && lm[12].y < lm[10].y && lm[16].y < lm[14].y;
        const isPoint = lm[8].y < lm[6].y && lm[12].y > lm[10].y;

        if(currentState === 'INIT' && isFist) handSequence.closed = true;
        if(currentState === 'INIT' && handSequence.closed && isOpen) { fanCards(); handSequence.closed = false; }
        if(currentState === 'FANNED') {
            updateHover(lm[8].x);
            if(isPoint && !selectTimer) {
                selectTimer = setTimeout(() => { pickCard(lm[8].x); selectTimer = null; }, 1300);
            } else if (!isPoint) { clearTimeout(selectTimer); selectTimer = null; }
        }
        if(currentState === 'REVEALED') {
            if(isOpen) handSequence.open = true;
            if(handSequence.open && isFist) { resetMagic(); handSequence.open = false; }
        }
    });

    document.getElementById('start-btn').addEventListener('click', () => {
        const cam = new Camera(document.getElementById('video-input'), {
            onFrame: async () => await hands.send({image: document.getElementById('video-input')}),
            width: 640, height: 480
        });
        cam.start().then(() => {
            document.getElementById('loader').style.opacity = '0';
            setTimeout(() => { document.getElementById('loader').style.display = 'none'; initThree(); }, 1500);
        });
    });

    window.addEventListener('resize', () => {
        if(!camera) return;
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });
</script>
</body>
</html>